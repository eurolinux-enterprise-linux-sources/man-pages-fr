.\" t
.\" Hey Emacs! This file is -*- nroff -*- source.
.\"
.\" Copyright (C) 2006 Michael Kerrisk <mtk.manpages@gmail.com>
.\"
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one.
.\"
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  The author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\"
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\"
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH MQ_NOTIFY 3 "15 septembre 2009" Linux "Manuel du programmeur Linux"
.SH NOM
mq_notify \- S'enregistrer pour la réception d'une notification de l'arrivée
d'un nouveau message
.SH SYNOPSIS
.nf
\fB#include <mqueue.h>\fP
.sp
\fBmqd_t mq_notify(mqd_t \fP\fImqdes\fP\fB, const struct sigevent *\fP\fInotification\fP\fB);\fP
.fi
.sp
Effectuez l'édition des liens avec l'option \fI\-lrt\fP.
.SH DESCRIPTION
\fBmq_notify\fP() permet à un processus appelant de s'enregistrer ou de ne plus
s'enregistrer pour délivrer une notification asynchrone lorsqu'un message
entre dans une file de messages vide référencée par le descripteur \fImqdes\fP.

L'argument \fInotification\fP est un pointeur vers une structure \fIsigevent\fP
qui est définie comme suit\ :
.in +4n
.nf

union sigval {          /* Data passed with notification */
    int     sival_int;         /* Integer value */
    void   *sival_ptr;         /* Pointer value */
};

struct sigevent {
    int          sigev_notify; /* Notification method */
    int          sigev_signo;  /* Notification signal */
    union sigval sigev_value;  /* Data passed with
                                  notification */
    void       (*sigev_notify_function) (union sigval);
                               /* Function for thread
                                  notification */
    void        *sigev_notify_attributes;
                               /* Thread function attributes */
};
.fi
.in
.PP
Si \fInotification\fP est un pointeur non NULL, alors \fBmq_notify\fP() enregistre
le processus appelant afin de recevoir les notifications. Le champ
\fIsigev_notify\fP de \fIsigevent\fP qui pointe vers \fInotification\fP spécifie
comment la notification est réalisée. Ce champ possède l'une des valeurs
suivantes\ :
.TP 
\fBSIGEV_NONE\fP
.\" When is SIGEV_NONE useful?
Une notification «\ null\ »\ : le processus appelant est enregistré comme
destinataire des notifications, mais aucune notification n'est envoyée
lorsqu'un message arrive.
.TP 
\fBSIGEV_SIGNAL\fP
.\" I don't know of other implementations that set
.\" si_pid and si_uid -- MTK
Notifier le processus en envoyant le signal spécifié dans \fIsigev_signo\fP. Si
le signal est attrapé par un gestionnaire de signaux qui a été enregistré
avec \fBsigaction\fP(2) et le drapeau \fBSA_SIGINFO\fP, alors les champs suivants
sont définis dans la structure \fIsiginfo_t\fP qui est passée en second
argument du gestionnaire\ : \fIsi_code\fP est défini à \fBSI_MESGQ\fP\ ;
\fIsi_signo\fP est défini au numéro du signal\ ; \fIsi_value\fP est défini à la
valeur spécifiée par \fInotification\->sigev_value\fP\ ; \fIsi_pid\fP est
défini au pid du processus qui a envoyé le message\ ; et \fIsi_uid\fP est
défini à l'UID du processus qui a envoyé le message. Les mêmes informations
sont disponibles si le signal est accepté avec \fBsigwaitinfo\fP(2).
.TP 
\fBSIGEV_THREAD\fP
Envoyer des notifications en invoquant
\fInotification\->sigev_notify_function\fP comme fonction de démarrage d'un
nouveau thread. La fonction est invoquée avec
\fInotification\->sigev_value\fP comme seul argument. Si
\fInotification\->sigev_notify_attributes\fP est non NULL, alors elle doit
pointer vers une structure \fIpthread_attr_t\fP qui définit les attributs du
thread (consultez \fBpthread_attr_init\fP(3)).
.PP
Seul un processus peut être enregistré pour recevoir les notifications d'une
file de messages.

Si \fInotification\fP est NULL, et si le processus appelant est actuellement
enregistré pour recevoir des notifications de cette file de messages, alors
l'enregistrement est supprimé\ ; un autre processus peut s'enregistrer pour
recevoir les notifications de cette file.

Une notification de message n'est créée que lorsqu'un nouveau message arrive
et que la file est vide. Si la file n'est pas vide à ce moment,
\fBmq_notify\fP() est appelée, alors une notification sera créée après que la
file soit vidée et qu'un nouveau message arrive.

Si un autre processus ou thread attend pour lire un message d'une file vide
avec \fBmq_receive\fP(3), alors tout enregistrement de notification de message
est ignoré\ : le message est délivré au processus ou au thread appelant avec
\fBmq_receive\fP(3) et l'enregistrement de notification de message garde son
effet.

Une notification apparaît une seule fois\ : après qu'une notification soit
délivrée, l'enregistrement de notification est supprimé et d'autre processus
peuvent s'enregistrer. Si le processus notifié souhaite recevoir la
prochaine notification, il peut utiliser \fBmq_notify\fP() pour demander une
autre notification. Cela doit être fait avant de vider tous les messages non
lus de la file (Placer la file en mode non bloquant est utile pour la vider
sans la bloquer une seule fois si elle est vide).
.SH "VALEUR RENVOYÉE"
Si elle réussit, la fonction \fBmq_notify\fP() renvoie 0. En cas d'erreur, elle
renvoie \-1 et définit \fIerrno\fP en conséquence.
.SH ERREURS
.TP 
\fBEBADF\fP
Le descripteur spécifié dans \fImqdes\fP n'est pas valable.
.TP 
\fBEBUSY\fP
Un autre processus est déjà enregistré pour recevoir les notifications de
cette file de messages.
.TP 
\fBEINVAL\fP
\fInotification\->sigev_notify\fP n'est pas l'une des valeurs permises\ ; ou
\fInotification\->sigev_notify\fP vaut \fBSIGEV_SIGNAL\fP et
\fInotification\->sigev_signo\fP n'est pas un numéro de signal valable.
.TP 
\fBENOMEM\fP
Mémoire insuffisante.
.PP
.\" Linux does not do this
POSIX.1\-2008 dit qu'une implémentation \fIpourrait\fP générer une erreur
\fBEINVAL\fP si \fInotification\fP est NULL et si l'appelant n'a pas souscrit aux
notifications de la file \fImqdes\fP.
.SH CONFORMITÉ
POSIX.1\-2001.
.SH EXEMPLE
Le programme suivant enregistre une requête de notification pour une file de
messages nommée avec l'un des arguments de la ligne de commande. La
notification est réalisée en créant un thread. Le thread exécute une
fonction qui lit un message provenant de la file puis le processus se
termine.
.nf

#include <pthread.h>
#include <mqueue.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#define handle_error(msg) \e
    do { perror(msg); exit(EXIT_FAILURE); } while (0)

static void                     /* Thread start function */
tfunc(union sigval sv)
{
    struct mq_attr attr;
    ssize_t nr;
    void *buf;
    mqd_t mqdes = *((mqd_t *) sv.sival_ptr);

    /* Determine max. msg size; allocate buffer to receive msg */

    if (mq_getattr(mqdes, &attr) == \-1)
        handle_error("mq_getattr");
    buf = malloc(attr.mq_msgsize);
    if (buf == NULL)
        handle_error("malloc");

    nr = mq_receive(mqdes, buf, attr.mq_msgsize, NULL);
    if (nr == \-1)
        handle_error("mq_receive");

    printf("Read %ld bytes from MQ\en", (long) nr);
    free(buf);
    exit(EXIT_SUCCESS);         /* Terminate the process */
}

int
main(int argc, char *argv[])
{
    mqd_t mqdes;
    struct sigevent not;

    if (argc != 2) {
	fprintf(stderr, "Usage: %s <mq\-name>\en", argv[0]);
	exit(EXIT_FAILURE);
    }

    mqdes = mq_open(argv[1], O_RDONLY);
    if (mqdes == (mqd_t) \-1)
        handle_error("mq_open");

    not.sigev_notify = SIGEV_THREAD;
    not.sigev_notify_function = tfunc;
    not.sigev_notify_attributes = NULL;
    not.sigev_value.sival_ptr = &mqdes;   /* Arg. to thread func. */
    if (mq_notify(mqdes, &not) == \-1)
        handle_error("mq_notify");

    pause();    /* Le processus sera terminé par la fonction du proc. */
}
.fi
.SH "VOIR AUSSI"
\fBmq_close\fP(3), \fBmq_getattr\fP(3), \fBmq_open\fP(3), \fBmq_receive\fP(3),
\fBmq_send\fP(3), \fBmq_unlink\fP(3), \fBmq_overview\fP(7)
.SH COLOPHON
Cette page fait partie de la publication 3.23 du projet \fIman\-pages\fP
Linux. Une description du projet et des instructions pour signaler des
anomalies peuvent être trouvées à l'adresse
<URL:http://www.kernel.org/doc/man\-pages/>.
.SH TRADUCTION
Depuis 2010, cette traduction est maintenue à l'aide de l'outil
po4a <URL:http://po4a.alioth.debian.org/> par l'équipe de
traduction francophone au sein du projet perkamon
<URL:http://alioth.debian.org/projects/perkamon/>.
.PP
Christophe Blaess <URL:http://www.blaess.fr/christophe/> (1996-2003),
Alain Portal <URL:http://manpagesfr.free.fr/> (2003-2006).
Florentin Duneau et l'équipe francophone de traduction de Debian\ (2006-2009).
.PP
Veuillez signaler toute erreur de traduction en écrivant à
<perkamon\-l10n\-fr@lists.alioth.debian.org>.
.PP
Vous pouvez toujours avoir accès à la version anglaise de ce document en
utilisant la commande
«\ \fBLC_ALL=C\ man\fR \fI<section>\fR\ \fI<page_de_man>\fR\ ».
