.\" Copyright (c) 2008 Linux Foundation, written by Michael Kerrisk
.\"     <mtk.manpages@gmail.com>
.\"
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one.
.\"
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  The author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\"
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\"
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH PTHREAD_CANCEL 3 "17 novembre 2008" Linux "Manuel du programmeur Linux"
.SH NOM
pthread_cancel \- Envoyer une requête d'annulation à un thread
.SH SYNOPSIS
.nf
\fB#include <pthread.h>\fP

\fBint pthread_cancel(pthread_t \fP\fIthread\fP\fB);\fP
.sp
Compilez et effectuez l'édition des liens avec l'option \fI\-pthread\fP.
.SH DESCRIPTION
La fonction \fBpthread_cancel\fP() envoie une requête d'annulation au thread
\fIthread\fP. Si et quand le thread ciblé réagit à la requête d'annulation
dépend de deux attributs qui sont sous le contrôle de ce thread\ : son état
d'annulation (\fIstate\fP) et son mode d'annulation (\fItype\fP).

L'état d'annulation d'un thread, déterminé par \fBpthread_setcancelstate\fP(3),
peut être activé (\fIenabled\fP), c'est le défaut pour les nouveaux threads, ou
désactivé (\fIdisabled\fP). Si un thread désactive l'annulation, alors une
demande d'annulation restera dans la file d'attente jusqu'à ce que le thread
active l'annulation. Si un thread active l'annulation, alors son mode
d'annulation va déterminer le moment où cette annulation est effectuée.

Le mode d'annulation d'un thread, déterminé par \fBpthread_setcanceltype\fP(3),
peut être asynchrone (\fIasynchronous\fP) ou retardée (\fIdeferred\fP), qui est le
mode par défaut pour les nouveaux threads. Un mode d'annulation asynchrone
signifie que le thread peut être annulé à tout moment (d'ordinaire
immédiatement, mais ce n'est pas garanti). Un mode d'annulation retardé
signifie que l'annulation peut être retardée jusqu'à ce que le thread
appelle une fonction qui est un point d'annulation (\fIcancellation
point\fP). Une liste des fonctions qui sont ou peuvent être des points
d'annulation est donnée dans \fIpthreads\fP(7).

Quand une requête d'annulation est traitée, les étapes suivantes sont
effectuées pour \fIthread\fP (dans cet ordre)\ :
.IP 1. 3
Les gestionnaires de nettoyage sont dépilés (dans l'ordre inverse dans
lequel ils ont été empilés) et appelés (voir \fBpthread_cleanup_push\fP(3)).
.IP 2.
Les destructeurs de données spécifiques aux threads sont appelés, dans un
ordre non déterminé (voir \fBpthread_key_create\fP(3)).
.IP 3.
Le thread s'est terminé (voir \fBpthread_exit\fP(3)).
.PP
Les étapes ci\-dessus sont effectuées de manière asynchrone par rapport à
l'appel à \fBpthread_cancel\fP(). La valeur de retour de \fBpthread_cancel\fP() ne
fait qu'informer l'appelant si une requête d'annulation a été correctement
mise en file d'attente.
.PP
Après qu'un thread annulé s'est terminé, une demande de jointure par
\fBpthread_join\fP(3) renvoie \fBPTHREAD_CANCELED\fP comme état de sortie du
thread. Il faut noter que joindre un thread est la seule manière de savoir
si une annulation a terminé.
.SH "VALEUR RENVOYÉE"
En cas de réussite, \fBpthread_cancel\fP() renvoie 0\ ; en cas d'erreur, elle
renvoie un numéro d'erreur non nul.
.SH ERREURS
.TP 
\fBESRCH\fP
.\" .SH VERSIONS
.\" Available since glibc 2.0
Aucun thread avec pour identifiant \fIthread\fP n'a pu être trouvé.
.SH CONFORMITÉ
POSIX.1\-2001.
.SH NOTES
Sous Linux, l'annulation est implémentée par des signaux. Avec
l'implémentation NPTL, le premier signal temps\-réel (c'est\-à\-dire le signal
32) est utilisé dans ce but. Avec LinuxThreads, le second signal temps\-réel
est utilisé, si les signaux temps\-réels sont disponibles, sinon \fBSIGUSR2\fP
est utilisé à la place.
.SH EXEMPLE
Le programme ci\-dessous crée un thread puis l'annule. Le thread principal
joint le thread annulé pour vérifier que son état de sortie était bien
\fBPTHREAD_CANCELED\fP. La session suivante montre un exemple d'exécution\ :

.in +4n
.nf
$ ./a.out
thread_func(): started; cancellation disabled
main(): sending cancellation request
thread_func(): about to enable cancellation
main(): thread was canceled
.fi
.in
.SS "Source du programme"
\&
.nf
#include <pthread.h>
#include <stdio.h>
#include <errno.h>
#include <stdlib.h>
#include <unistd.h>

#define handle_error_en(en, msg) \e
        do { errno = en; perror(msg); exit(EXIT_FAILURE); } while (0)

static void *
thread_func(void *ignored_argument)
{
    int s;

    /* Disable cancellation for a while, so that we don\(aqt
       immediately react to a cancellation request */

    s = pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL);
    if (s != 0)
        handle_error_en(s, "pthread_setcancelstate");

    printf("thread_func(): started; cancellation disabled\en");
    sleep(5);
    printf("thread_func(): about to enable cancellation\en");

    s = pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);
    if (s != 0)
        handle_error_en(s, "pthread_setcancelstate");

    /* sleep() is a cancellation point */

    sleep(1000);        /* Should get canceled while we sleep */

    /* Should never get here */

    printf("thread_func(): not canceled!\en");
    return NULL;
}

int
main(void)
{
    pthread_t thr;
    void *res;
    int s;

    /* Start a thread and then send it a cancellation request */

    s = pthread_create(&thr, NULL, &thread_func, NULL);
    if (s != 0)
        handle_error_en(s, "pthread_create");

    sleep(2);           /* Give thread a chance to get started */

    printf("main(): sending cancellation request\en");
    s = pthread_cancel(thr);
    if (s != 0)
        handle_error_en(s, "pthread_cancel");

    /* Join with thread to see what its exit status was */

    s = pthread_join(thr, &res);
    if (s != 0)
        handle_error_en(s, "pthread_join");

    if (res == PTHREAD_CANCELED)
        printf("main(): thread was canceled\en");
    else
        printf("main(): thread wasn\(aqt canceled (shouldn\(aqt happen!)\en");
    exit(EXIT_SUCCESS);
}
.fi
.SH "VOIR AUSSI"
\fBpthread_cleanup_push\fP(3), \fBpthread_create\fP(3), \fBpthread_exit\fP(3),
\fBpthread_join\fP(3), \fBpthread_key_create\fP(3), \fBpthread_setcancelstate\fP(3),
\fBpthread_setcanceltype\fP(3), \fBpthread_testcancel\fP(3), \fBpthreads\fP(7)
.SH COLOPHON
Cette page fait partie de la publication 3.23 du projet \fIman\-pages\fP
Linux. Une description du projet et des instructions pour signaler des
anomalies peuvent être trouvées à l'adresse
<URL:http://www.kernel.org/doc/man\-pages/>.
.SH TRADUCTION
Depuis 2010, cette traduction est maintenue à l'aide de l'outil
po4a <URL:http://po4a.alioth.debian.org/> par l'équipe de
traduction francophone au sein du projet perkamon
<URL:http://alioth.debian.org/projects/perkamon/>.
.PP
Denis Barbier (2010).
.PP
Veuillez signaler toute erreur de traduction en écrivant à
<perkamon\-l10n\-fr@lists.alioth.debian.org>.
.PP
Vous pouvez toujours avoir accès à la version anglaise de ce document en
utilisant la commande
«\ \fBLC_ALL=C\ man\fR \fI<section>\fR\ \fI<page_de_man>\fR\ ».
