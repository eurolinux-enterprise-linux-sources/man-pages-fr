.\" Copyright (C) 2005, 2013 Michael Kerrisk (mtk.manpages@gmail.com)
.\" a few fragments from an earlier (1996) version by
.\" Andries Brouwer (aeb@cwi.nl) remain.
.\"
.\" %%%LICENSE_START(VERBATIM)
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one.
.\"
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  The author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\"
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\" %%%LICENSE_END
.\"
.\" Rewritten old page, 960210, aeb@cwi.nl
.\" Updated, added strtok_r. 2000-02-13 Nicolás Lichtmaier <nick@debian.org>
.\" 2005-11-17, mtk: Substantial parts rewritten
.\" 2013-05-19, mtk: added much further detail on the operation of strtok()
.\"
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH STRTOK 3 "19 mai 2013" GNU "Manuel du programmeur Linux"
.SH NOM
strtok, strtok_r \- Extraire des mots d'une chaîne
.SH SYNOPSIS
.nf
\fB#include <string.h>\fP
.sp
\fBchar *strtok(char *\fP\fIstr\fP\fB, const char *\fP\fIdelim\fP\fB);\fP
.sp
\fBchar *strtok_r(char *\fP\fIstr\fP\fB, const char *\fP\fIdelim\fP\fB, char **\fP\fIsaveptr\fP\fB);\fP
.fi
.sp
.in -4n
Exigences de macros de test de fonctionnalités pour la glibc (consultez
\fBfeature_test_macros\fP(7))\ :
.in
.sp
.ad l
\fBstrtok_r\fP()\ : _SVID_SOURCE || _BSD_SOURCE || _POSIX_C_SOURCE\ >=\ 1 ||
_XOPEN_SOURCE || _POSIX_SOURCE
.ad b
.SH DESCRIPTION
La fonction \fBstrtok\fP() scinde une chaîne en une séquence de zéro, un ou
plusieurs éléments lexicaux non vides. Lors du premier appel à \fBstrtok\fP(),
la chaîne à scinder doit être spécifiée dans \fIstr\fP. Dans chaque appel
ultérieur fait pour analyser la même chaîne, \fIstr\fP devrait normalement
valoir NULL.

L'argument \fIdelimit\fP indique l'ensemble des octets qui délimitent les
éléments dans la chaîne à analyser. La chaîne de séparateurs \fIdelimit\fP peut
être différente à chaque appel sur la même chaîne.

Chaque appel à \fBstrtok\fP() renvoie un pointeur sur une chaîne, terminée par
un octet nul, contenant l'élément suivant. Cette chaîne n'inclut pas le
séparateur. S'il n'y a plus d'éléments, \fBstrtok\fP renvoie NULL.

Une séquence d'appels à \fBstrtok\fP() qui s'exécute sur la même chaîne gère un
pointeur qui indique le point de départ de la recherche pour l'élément
lexical suivant. Le premier appel à \fBstrtok\fP() positionne ce pointeur sur
le premier octet de la chaîne. Le début de l'élément lexical suivant est
déterminé en parcourant \fIstr\fP jusqu'à l'octet suivant qui ne soit pas un
séparateur. Lorsqu'un tel octet est rencontré, il est pris comme point de
départ de l'élément lexical suivant. Si on ne trouve plus d'octet qui ne
soit pas un séparateur, alors il n'y a plus d'élément lexical dans la
chaîne, et \fBstrtok\fP() renvoie la valeur NULL. (Ainsi, pour une chaîne vide
ou qui ne contient que des séparateurs, \fBstrtok\fP() renverra la valeur NULL
dès le premier appel).

La fin de chaque élément lexical est déterminée en parcourant la chaîne
jusqu'à ce que l'octet suivant soit un délimiteur, ou jusqu'à ce qu'on
rencontre l'octet vide (\(aq\e0\(aq). Si un délimiteur est trouvé, il est
écrasé par un octet vide pour signifier la fin de l'élément lexical en cours
de détermination, et \fBstrtok\fP() positionne un pointeur sur l'octet
suivant\ ;\ ce pointeur marque le point de départ de la recherche de l'élément
lexical suivant. Dans ce cas, \fBstrtok\fP() renvoie un pointeur vers le début
de l'élément lexical qui vient d'être isolé.

De ce qui précède, il découle qu'une séquence de deux séparateurs contigus
ou plus est considérée comme un seul séparateur et que les séparateurs en
début et en fin de chaîne sont ignorés. Les éléments renvoyés par
\fBstrtok\fP() sont toujours des chaînes non vides. Si l'on considère par
exemple la chaîne «\fIaaa;;bbb,\fP», les appels successifs à \fBstrtok\fP() pour
lequel le séparateur serait «\fI;,\fP» renverraient les chaînes «\fIaaa\fP» and
«\fIbbb\fP», puis un pointeur NULL.

La fonction \fBstrtok_r\fP() est la version réentrante de la fonction
\fBstrtok\fP(). L'argument \fIsaveptr\fP est un pointeur sur une variable \fIchar\ *\fP utilisée de manière interne à \fBstrtok_r\fP() afin de maintenir le contexte
entre les appels successifs qui analysent la même chaîne.

Au premier appel de \fBstrtok_r\fP(), \fIstr\fP doit pointer sur la chaîne à
analyser et la valeur de \fIsaveptr\fP est ignorée. Dans les appels suivants,
\fIstr\fP doit être NULL et \fIsaveptr\fP ne doit pas être modifié depuis le
précédent appel.

Différentes chaînes peuvent être analysées de manière concurrente en
utilisant des séquences d'appels à \fBstrtok_r\fP() qui spécifient différents
arguments \fIsaveptr\fP.
.SH "VALEUR RENVOYÉE"
Les fonctions \fBstrtok\fP() et \fBstrtok_r\fP() renvoient un pointeur sur
l'élément lexical suivant, ou NULL s'il n'y en a plus.
.SH ATTRIBUTS
.SS "Multithreading (voir pthreads(7))"
La fonction \fBstrtok\fP() n'est pas sûre dans un contexte multithread.
.LP
La fonction \fBstrtok_r\fP() est sûre dans un contexte multithread.
.SH CONFORMITÉ
.TP 
\fBstrtok\fP()
SVr4, POSIX.1\-2001, BSD\ 4.3, C89, C99.
.TP 
\fBstrtok_r\fP()
POSIX.1\-2001.
.SH BOGUES
Faites attention quand vous utilisez ces fonctions. Si vous les utilisez,
prenez note des informations suivantes\ :
.IP * 2
Ces fonctions modifient leur premier paramètre.
.IP *
Ces fonctions ne peuvent pas être utilisées avec des chaînes constantes.
.IP *
L'identité du délimiteur est perdue.
.IP *
La fonction \fBstrtok\fP() utilise un tampon statique et n'est donc pas sûre
dans un contexte multithread. Dans ce cas, il vaut mieux utiliser
\fBstrtok_r\fP().
.SH EXEMPLE
Le programme ci\-dessous utilise des boucles imbriquées qui utilisent
\fBstrtok_r\fP() pour scinder une chaîne en une hiérarchie d'éléments à deux
niveaux. Le premier argument de la ligne de commande indique la chaîne à
analyser. Le second argument indique le ou les séparateurs utilisés pour
séparer la chaîne en éléments «\ majeurs\ ». Le troisième argument indique
le ou les séparateurs utilisés pour séparer les éléments «\ majeurs\ » en
sous\-éléments.
.PP
Voici un exemple de la sortie produite par ce programme\ :
.PP
.in +4n
.nf
$\fB ./a.out \(aqa/bbb///cc;xxx:yyy:\(aq \(aq:;\(aq \(aq/\(aq\fP
1: a/bbb///cc
         \-\-> a
         \-\-> bbb
         \-\-> cc
2: xxx
         \-\-> xxx
3: yyy
         \-\-> yyy
.fi
.in
.SS "Source du programme"
\&
.nf
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int
main(int argc, char *argv[])
{
    char *str1, *str2, *token, *subtoken;
    char *saveptr1, *saveptr2;
    int j;

    if (argc != 4) {
        fprintf(stderr, "Usage: %s string delim subdelim\en",
                argv[0]);
        exit(EXIT_FAILURE);
    }

    for (j = 1, str1 = argv[1]; ; j++, str1 = NULL) {
        token = strtok_r(str1, argv[2], &saveptr1);
        if (token == NULL)
            break;
        printf("%d: %s\en", j, token);

        for (str2 = token; ; str2 = NULL) {
            subtoken = strtok_r(str2, argv[3], &saveptr2);
            if (subtoken == NULL)
                break;
            printf("\t \-\-> %s\en", subtoken);
        }
    }

    exit(EXIT_SUCCESS);
}
.fi
.PP
Un autre exemple de programme qui utilise \fBstrtok\fP() se trouve dans
\fBgetaddrinfo_a\fP(3).
.SH "VOIR AUSSI"
\fBindex\fP(3), \fBmemchr\fP(3), \fBrindex\fP(3), \fBstrchr\fP(3), \fBstring\fP(3),
\fBstrpbrk\fP(3), \fBstrsep\fP(3), \fBstrspn\fP(3), \fBstrstr\fP(3), \fBwcstok\fP(3)
.SH COLOPHON
Cette page fait partie de la publication 3.52 du projet \fIman\-pages\fP
Linux. Une description du projet et des instructions pour signaler des
anomalies peuvent être trouvées à l'adresse
\%http://www.kernel.org/doc/man\-pages/.
.SH TRADUCTION
Depuis 2010, cette traduction est maintenue à l'aide de l'outil
po4a <http://po4a.alioth.debian.org/> par l'équipe de
traduction francophone au sein du projet perkamon
<http://perkamon.alioth.debian.org/>.
.PP
Christophe Blaess <http://www.blaess.fr/christophe/> (1996-2003),
Alain Portal <http://manpagesfr.free.fr/> (2003-2006).
Nicolas François et l'équipe francophone de traduction de Debian\ (2006-2009).
.PP
Veuillez signaler toute erreur de traduction en écrivant à
<perkamon\-fr@traduc.org>.
.PP
Vous pouvez toujours avoir accès à la version anglaise de ce document en
utilisant la commande
«\ \fBLC_ALL=C\ man\fR \fI<section>\fR\ \fI<page_de_man>\fR\ ».
