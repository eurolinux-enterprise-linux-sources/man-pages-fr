.\"  Copyright (C) 2003  Davide Libenzi
.\"  Davide Libenzi <davidel@xmailserver.org>
.\"
.\" %%%LICENSE_START(GPLv2+_SW_3_PARA)
.\"  This program is free software; you can redistribute it and/or modify
.\"  it under the terms of the GNU General Public License as published by
.\"  the Free Software Foundation; either version 2 of the License, or
.\"  (at your option) any later version.
.\"
.\"  This program is distributed in the hope that it will be useful,
.\"  but WITHOUT ANY WARRANTY; without even the implied warranty of
.\"  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.\"  GNU General Public License for more details.
.\"
.\" You should have received a copy of the GNU General Public
.\" License along with this manual; if not, see
.\" <http://www.gnu.org/licenses/>.
.\" %%%LICENSE_END
.\"
.\" 2007-04-30: mtk, Added description of epoll_pwait()
.\"
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH EPOLL_WAIT 2 "17 août 2012" Linux "Manuel du programmeur Linux"
.SH NOM
epoll_wait, epoll_pwait \- Attendre un événement sur un descripteur epoll
.SH SYNOPSIS
.nf
\fB#include <sys/epoll.h>\fP
.sp
\fBint epoll_wait(int \fP\fIepfd\fP\fB, struct epoll_event *\fP\fIevents\fP\fB,\fP
\fB               int \fP\fImaxevents\fP\fB, int \fP\fItimeout\fP\fB);\fP
\fBint epoll_pwait(int \fP\fIepfd\fP\fB, struct epoll_event *\fP\fIevents\fP\fB,\fP
\fB               int \fP\fImaxevents\fP\fB, int \fP\fItimeout\fP\fB,\fP
\fB               const sigset_t *\fP\fIsigmask\fP\fB);\fP
.fi
.SH DESCRIPTION
L'appel système \fBepoll_wait\fP() attend un événement sur l'instance
\fBepoll\fP(7) indiquée par le descripteur \fIepfd\fP. La zone mémoire pointée par
\fIevents\fP contiendra les événements disponibles pour l'appelant. Un maximum
de \fImaxevents\fP événements sont renvoyés par \fBepoll_wait\fP(). Le paramètre
\fImaxevents\fP doit être supérieur à zéro.

L'argument \fItimeout\fP définit le temps minimal, en milliseconde, pendant
lequel \fBepoll_wait\fP() attendra (cet intervalle sera arrondi à la
granularité de l'horloge système, et les délais d'ordonnancement du noyau
signifient que l'intervalle de blocage pourrait être dépassé d'une petite
quantité). Un \fItimeout\fP de \-1 force \fBepoll_wait\fP() à attendre
indéfiniment, alors qu'un \fItimeout\fP nul force \fBepoll_wait\fP() à revenir
immédiatement, même si aucun événement n'est disponible.

La structure \fIepoll_event\fP est définie ainsi\ :
.sp
.in +4n
.nf
typedef union epoll_data {
    void    *ptr;
    int      fd;
    uint32_t u32;
    uint64_t u64;
} epoll_data_t;

struct epoll_event {
    uint32_t     events;    /* Événements epoll */
    epoll_data_t data;      /* Variable utilisateur */
};
.fi
.in

Le champ \fIdata\fP de la structure renvoyée contiendra les mêmes données que
lors de l'appel \fBepoll_ctl\fP(2) (\fBEPOLL_CTL_ADD\fP, \fBEPOLL_CTL_MOD\fP) tandis
que le champ \fIevents\fP contiendra le masque de bit des événements
disponibles.
.SS epoll_pwait()
La relation entre \fBepoll_wait\fP() et \fBepoll_pwait\fP() est similaire à celle
entre \fBselect\fP(2) et \fBpselect\fP(2)\ : de même que \fBpselect\fP(2),
\fBepoll_pwait\fP() permet à une application d'attendre de façon sûre qu'un
descripteur de fichier soit prêt ou qu'un signal arrive.

L'appel à \fBepoll_pwait\fP() suivant\ :
.nf

    ready = epoll_pwait(epfd, &events, maxevents, timeout, &sigmask);

.fi
est équivalent à exécuter de façon \fIatomique\fP les appels suivants\ :
.nf

    sigset_t origmask;

    sigprocmask(SIG_SETMASK, &sigmask, &origmask);
    ready = epoll_wait(epfd, &events, maxevents, timeout);
    sigprocmask(SIG_SETMASK, &origmask, NULL);
.fi
.PP
Le paramètre \fIsigmask\fP peut valoir NULL, auquel cas, \fBepoll_pwait\fP() est
équivalent à \fBepoll_wait\fP().
.SH "VALEUR RENVOYÉE"
Lorsqu'il réussit, l'appel \fBepoll_wait\fP() renvoie le nombre de descripteurs
prêts pour les E/S demandées, ou zéro si aucun descripteur n'est devenu prêt
pendant la durée \fItimeout\fP millisecondes. Si une erreur se produit,
\fBepoll_wait\fP() renvoie \-1 et \fIerrno\fP contient le code approprié.
.SH ERREURS
.TP 
\fBEBADF\fP
\fIepfd\fP n'est pas un descripteur de fichier valable.
.TP 
\fBEFAULT\fP
La zone mémoire pointée par \fIevents\fP n'est pas accessible en écriture.
.TP 
\fBEINTR\fP
L'appel a été interrompu par un signal avant qu'aucun des événements
demandés n'ait lieu ou que la temporisation \fItimeout\fP n'expire\ ; consultez
\fBsignal\fP(7).
.TP 
\fBEINVAL\fP
Le descripteur \fIepfd\fP fourni n'est pas un descripteur \fBepoll\fP, ou le
paramètre \fImaxevents\fP est inférieur ou égal à zéro.
.SH VERSIONS
.\" To be precise: kernel 2.5.44.
.\" The interface should be finalized by Linux kernel 2.5.66.
\fBepoll_wait\fP a été introduite dans le noyau Linux\ 2.6. La prise en charge
par la glibc a été ajoutée dans la version\ 2.3.2.

\fBepoll_pwait\fP a été introduite dans le noyau Linux\ 2.6.19. La prise en
charge par la glibc a été ajoutée dans la version\ 2.6.
.SH CONFORMITÉ
\fBepoll_wait\fP() est spécifique à Linux.
.SH NOTES
Alors qu'un thread est bloqué par un appel de \fBepoll_pwait\fP(), un autre
thread pourrait ajouter un descripteur de fichier à l'instance \fBepoll\fP
attendue. Si le nouveau descripteur de fichier devient prêt, il forcera le
déblocage de l'appel \fBepoll_wait\fP().

Consultez \fBselect\fP(2) pour une discussion sur ce qui pourrait arriver si un
descripteur de fichier, dans une instance \fBepoll\fP, surveillé par
\fBepoll_wait\fP() est fermé dans un autre thread.
.SH BOGUES
Dans les noyaux jusqu'à la version\ 2.6.37, une valeur \fItimeout\fP plus grande
qu'environ \fILONG_MAX / HZ\fP millisecondes est traitée comme \-1 (c'est\-à\-dire
l'infini). Ainsi, par exemple, sur un système où \fIsizeof(long)\fP est 4 et la
valeur \fIHZ\fP du noyau est 1000, cela signifie que les temps d'attente
supérieurs à 35,79\ minutes sont traités comme l'infini.
.SH "VOIR AUSSI"
\fBepoll_create\fP(2), \fBepoll_ctl\fP(2), \fBepoll\fP(7)
.SH COLOPHON
Cette page fait partie de la publication 3.52 du projet \fIman\-pages\fP
Linux. Une description du projet et des instructions pour signaler des
anomalies peuvent être trouvées à l'adresse
\%http://www.kernel.org/doc/man\-pages/.
.SH TRADUCTION
Depuis 2010, cette traduction est maintenue à l'aide de l'outil
po4a <http://po4a.alioth.debian.org/> par l'équipe de
traduction francophone au sein du projet perkamon
<http://perkamon.alioth.debian.org/>.
.PP
Christophe Blaess <http://www.blaess.fr/christophe/> (1996-2003),
Alain Portal <http://manpagesfr.free.fr/> (2003-2006).
Julien Cristau et l'équipe francophone de traduction de Debian\ (2006-2009).
.PP
Veuillez signaler toute erreur de traduction en écrivant à
<perkamon\-fr@traduc.org>.
.PP
Vous pouvez toujours avoir accès à la version anglaise de ce document en
utilisant la commande
«\ \fBLC_ALL=C\ man\fR \fI<section>\fR\ \fI<page_de_man>\fR\ ».
