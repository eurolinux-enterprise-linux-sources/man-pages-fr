.\" Hey Emacs! This file is -*- nroff -*- source.
.\"
.\" Copyright (c) 1992 Drew Eckhardt, March 28, 1992
.\" and Copyright (c) 2002, 2004, 2005, 2008 Michael Kerrisk
.\"
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one.
.\"
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  The author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\"
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\"
.\" Modified by Michael Haardt <michael@moria.de>
.\" Modified 1993-07-23 by Rik Faith <faith@cs.unc.edu>
.\" Modified 1996-01-13 by Arnt Gulbrandsen <agulbra@troll.no>
.\" Modified 1996-01-22 by aeb, following a remark by
.\"          Tigran Aivazian <tigran@sco.com>
.\" Modified 1996-04-14 by aeb, following a remark by
.\"          Robert Bihlmeyer <robbe@orcus.ping.at>
.\" Modified 1996-10-22 by Eric S. Raymond <esr@thyrsus.com>
.\" Modified 2001-05-04 by aeb, following a remark by
.\"          Håvard Lygre <hklygre@online.no>
.\" Modified 2001-04-17 by Michael Kerrisk <mtk.manpages@gmail.com>
.\" Modified 2002-06-13 by Michael Kerrisk <mtk.manpages@gmail.com>
.\"     Added note on non-standard behavior when SIGCHLD is ignored.
.\" Modified 2002-07-09 by Michael Kerrisk <mtk.manpages@gmail.com>
.\"	Enhanced descriptions of 'resource' values for [gs]etrlimit()
.\" Modified 2003-11-28 by aeb, added RLIMIT_CORE
.\" Modified 2004-03-26 by aeb, added RLIMIT_AS
.\" Modified 2004-06-16 by Michael Kerrisk <mtk.manpages@gmail.com>
.\"     Added notes on CAP_SYS_RESOURCE
.\"
.\" 2004-11-16 -- mtk: the getrlimit.2 page, which formally included
.\" coverage of getrusage(2), has been split, so that the latter
.\" is now covered in its own getrusage.2.
.\"
.\" Modified 2004-11-16, mtk: A few other minor changes
.\" Modified 2004-11-23, mtk
.\"	Added notes on RLIMIT_MEMLOCK, RLIMIT_NPROC, and RLIMIT_RSS
.\"		to "CONFORMING TO"
.\" Modified 2004-11-25, mtk
.\"	Rewrote discussion on RLIMIT_MEMLOCK to incorporate kernel
.\"		2.6.9 changes.
.\"	Added note on RLIMIT_CPU error in older kernels
.\" 2004-11-03, mtk, Added RLIMIT_SIGPENDING
.\" 2005-07-13, mtk, documented RLIMIT_MSGQUEUE limit.
.\" 2005-07-28, mtk, Added descriptions of RLIMIT_NICE and RLIMIT_RTPRIO
.\" 2008-05-07, mtk / Peter Zijlstra, Added description of RLIMIT_RTTIME
.\"
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH GETRLIMIT 2 "6 octobre 2008" Linux "Manuel du programmeur Linux"
.SH NOM
getrlimit, setrlimit \- Lire/écrire les limites et utilisations des
ressources
.SH SYNOPSIS
\fB#include <sys/time.h>\fP
.br
\fB#include <sys/resource.h>\fP
.sp
\fBint getrlimit(int \fP\fIresource\fP\fB, struct rlimit *\fP\fIrlim\fP\fB);\fP
.br
\fBint setrlimit(int \fP\fIresource\fP\fB, const struct rlimit *\fP\fIrlim\fP\fB);\fP
.SH DESCRIPTION
\fBgetrlimit\fP() et \fBsetrlimit\fP() lisent ou écrivent les limites des
ressources systèmes. Chaque ressource a une limite souple et une limite
stricte définies par la structure \fIrlimit\fP (l'argument \fIrlim\fP de
\fBgetrlimit\fP() et \fBsetrlimit\fP())\ :
.PP
.in +4n
.nf
struct rlimit {
  rlim_t rlim_cur; /* limite souple */
  rlim_t rlim_max; /* limite stricte (plafond
                      de rlim_cur) */
};

.fi
.in
La limite souple est la valeur que le noyau prend en compte pour la
ressource correspondante. La limite stricte agit comme un plafond pour la
limite souple\ : un processus non privilégié peut seulement modifier sa
limite souple dans l'intervalle entre zéro et la limite stricte, et diminuer
(de manière irréversible) sa limite stricte. Un processus privilégié (sous
Linux\ : un processus ayant la capacité \fBCAP_SYS_RESOURCE\fP) peut modifier
ses deux limites à sa guise.
.PP
La valeur \fBRLIM_INFINITY\fP indique une limite infinie pour la ressource
(aussi bien pour \fBgetrlimit\fP() que pour \fBsetrlimit\fP()).
.PP
\fIresource\fP doit être l'un des éléments suivants\ :
.TP 
\fBRLIMIT_AS\fP
.\" since 2.0.27 / 2.1.12
Taille maximum de la mémoire virtuelle du processus en octets. Cette limite
affecte les appels à \fBbrk\fP(2), \fBmmap\fP(2) et \fBmremap\fP(2), qui échouent
avec l'erreur \fBENOMEM\fP en cas de dépassement de cette limite. De même,
l'extension de la pile automatique échouera (et générera un \fBSIGSEGV\fP qui
tuera le processus si aucune pile alternative n'a été définie par un appel à
\fBsigaltstack\fP(2)). Depuis que cette valeur est de type \fIlong\fP, sur les
machines où le type \fIlong\fP est sur 32 bits, soit cette limite est au plus 2
GiB, soit cette ressource est illimitée.
.TP 
\fBRLIMIT_CORE\fP
Taille maximum du fichier \fIcore\fP. Lorsqu'elle vaut zéro, aucun fichier
d'image noyau (Ndt\ : core dump) n'est créé. Lorsqu'elle ne vaut pas zéro,
les fichiers d'image noyau plus grands sont tronqués à cette taille.
.TP 
\fBRLIMIT_CPU\fP
Limite de temps CPU en secondes. Si un processus atteint cette limite
souple, il reçoit le signal \fBSIGXCPU\fP. L'action par défaut en est la
terminaison du processus. Mais le signal peut être capturé et le
gestionnaire peut renvoyer le contrôle au programme principal. Si le
processus continue à consommer du temps CPU, il recevra \fBSIGXCPU\fP toutes
les secondes jusqu'à atteindre sa limite stricte, où il recevra
\fBSIGKILL\fP. (Ceci correspond au comportement de Linux 2.2 à 2.6. Les
implémentations varient sur le comportement vis\(hyà\(hyvis d'un processus
qui continue à consommer du temps CPU après dépassement de sa limite
souple. Les applications portables qui doivent capturer ce signal devraient
prévoir une terminaison propre dès la première réception de \fBSIGXCPU\fP.)
.TP 
\fBRLIMIT_DATA\fP
Taille maximale du segment de données d'un processus (données initialisées,
non initialisées, et tas). Cette limite affecte les appels \fBbrk\fP(2) et
\fBsbrk\fP(2), qui échouent avec l'erreur \fBENOMEM\fP si la limite souple est
dépassée.
.TP 
\fBRLIMIT_FSIZE\fP
Taille maximale d'un fichier que le processus peut créer. Les tentatives
d'extension d'un fichier au\(hydelà de cette limite résultent en un signal
\fBSIGXFSZ\fP. Par défaut ce signal termine le processus, mais il peut être
capturé, et dans ce cas l'appel système concerné (par exemple \fBwrite\fP(2),
\fBtruncate\fP(2)) échoue avec l'erreur \fBEFBIG\fP.
.TP 
\fBRLIMIT_LOCKS\fP (Premiers Linux 2.4 seulement)
.\" to be precise: Linux 2.4.0-test9; no longer in 2.4.25 / 2.5.65
Une limite sur le nombre combiné de verrous \fBflock\fP(2) et \fBfcntl\fP(2) que
le processus peut établir.
.TP 
\fBRLIMIT_MEMLOCK\fP
Le nombre maximal d'octets de mémoire virtuelle que le processus peut
verrouiller en RAM. En pratique cette limite est arrondie vers le bas au
multiple de la taille de page le plus proche. Cette limite affecte
\fBmlock\fP(2) et \fBmlockall\fP(2) ainsi que l'opération \fBMAP_LOCKED\fP de
\fBmmap\fP(2). Depuis Linux 2.6.9, elle affecte aussi l'opération \fBSHM_LOCK\fP
de \fBshmctl\fP(2), où elle limite le nombre total d'octets dans des segments
de mémoire partagée (voir \fBshmget\fP(2)) que l'UID réel du processus appelant
peut verrouiller. Les verrous de \fBshmctl\fP(2) \fBSHM_LOCK\fP sont comptés
séparément des verrous de mémoire par processus établis par \fBmlock\fP(2),
\fBmlockall\fP(2) et \fBmmap\fP(2) \fBMAP_LOCKED\fP\ ; un processus peut verrouiller
des octets jusqu'à la limite dans chacune de ces catégories. Dans les noyaux
antérieurs à 2.6.9, cette limite contrôlait la quantité de mémoire qu'un
processus privilégié pouvait verrouiller. Depuis Linux 2.6.9, un processus
privilégie peut verrouiller autant de mémoire qu'il le souhaite, et cette
limite contrôle la quantité de mémoire pouvant être verrouillée par un
processus non privilégié.
.TP 
\fBRLIMIT_MSGQUEUE\fP (depuis Linux 2.6.8)
Indique la limite du nombre d'octets pouvant être alloués pour les files de
messages POSIX pour l'UID réel du processus appelant. Cette limite est
appliquée pour \fBmq_open\fP(3). Le nombre d'octets pour chaque file de
messages créée par l'utilisateur (jusqu'à sa destruction) est déterminé par
la formule suivante\ :
.nf

   octets = attr.mq_maxmsg * sizeof(struct msg_msg *) +
            attr.mq_maxmsg * attr.mq_msgsize

.fi
où \fIattr\fP est la structure \fImq_attr\fP passée comme quatrième argument à
\fBmq_open\fP(3).

Le premier terme de la formule, qui inclue \fIsizeof(struct msg_msg *)\fP (4\
octets sur Linux/i386) garantit que l'utilisateur ne peut pas créer un
nombre illimité de messages vides (ces messages consomment tout de même de
la mémoire système).
.TP 
\fBRLIMIT_NICE\fP (depuis Linux\ 2.6.12, voir la section BOGUES ci\(hydessous)
Indique un plafond pour la valeur de politesse du processus pouvant être
définie par \fBsetpriority\fP(2) ou \fBnice\fP(2). Le plafond réel pour la valeur
de politesse est calculé par la formule \fI20\ \-\ rlim_cur\fP. (Cette
bizarrerie apparaît car des nombres négatifs ne peuvent pas être utilisés
comme limites de ressources, en raison de leur signification souvent
particulière. Par exemple, \fBRLIM_INFINITY\fP est souvent la même chose que
\-1.)
.TP 
\fBRLIMIT_NOFILE\fP
Le nombre maximal de descripteurs de fichier qu'un processus peut ouvrir
simultanément. Les tentatives d'ouverture (\fBopen\fP(2), \fBpipe\fP(2),
\fBdup\fP(2), etc) dépassant cette limite renverront l'erreur
\fBEMFILE\fP. Historiquement, cette limite était appelée \fBRLIMIT_OFILE\fP sur
les BSD.
.TP 
\fBRLIMIT_NPROC\fP
Le nombre maximum de processus (ou plus précisément, sous Linux, de threads)
qui peuvent être créés pour l'UID réel du processus appelant. Une fois cette
limite atteinte, \fBfork\fP(2) échoue avec l'erreur \fBEAGAIN\fP.
.TP 
\fBRLIMIT_RSS\fP
.\" As at kernel 2.6.12, this limit still does nothing in 2.6 though
.\" talk of making it do something has surfaced from time to time in LKML
.\"       -- MTK, Jul 05
Indique la limite (en pages) pour la taille de l'ensemble résident du
processus (le nombre de pages de mémoire virtuelle en RAM). Cette limite n'a
d'effet que sous Linux 2.4.x où x\ <\ 30, et n'affecte que les appels
\fBmadvise\fP(2) indiquant \fBMADV_WILLNEED\fP.
.TP 
\fBRLIMIT_RTPRIO\fP (Depuis Linux 2.6.12, mais voir BOGUES)
Indique un plafond pour la priorité temps\(hyréel pouvant être appliquée au
processus par \fBsched_setscheduler\fP(2) et \fBsched_setparam\fP(2).
.TP 
\fBRLIMIT_RTTIME\fP (depuis Linux 2.6.25)
Indique une limite de la quantité de temps CPU qu'un processus ordonnancé
par une politique d'ordonnancement temps réel peut consommer sans bloquer
lors de l'exécution d'un appel système. À cause de cette limite le décompte
du temps CPU qu'il a consommé est remis à zéro à chaque fois qu'un processus
exécute un appel système bloquant. Le décompte du temps CPU n'est pas remis
à zéro si le processus continue d'essayer d'utiliser le CPU mais est
préempté, ou si sa tranche de temps expire, ou s'il appelle
\fBsched_yield\fP(2).

Quand la limite douce est atteinte, un signal \fBSIGXCPU\fP est envoyé au
processus. Si le processus attrape ou ignore ce signal et continue à
consommer du temps CPU, alors un signal \fBSIGXCPU\fP sera généré une fois par
seconde jusqu'à ce que la limite dure soit atteinte, ce qui provoque
l'envoie d'un signal \fBSIGKILL\fP au processus.

L'objectif de cette limite est d'empêcher un processus temps réel fou de
bloquer le système.
.TP 
\fBRLIMIT_SIGPENDING\fP (Depuis Linux 2.6.8)
.\" This replaces the /proc/sys/kernel/rtsig-max system-wide limit
.\" that was present in kernels <= 2.6.7.  MTK Dec 04
Spécifie la limite du nombre de signaux pouvant être mis en attente pour
l'UID réel du processus appelant. La vérification de cette limite prend en
compte à la fois les signaux classiques et les signaux
temps\(hyréel. Cependant, cette limite n'est appliquée que pour
\fBsigqueue\fP(2)\ ; il est toujours possible d'utiliser \fBkill\fP(2) pour mettre
en attente une instance de tout signal qui n'est pas déjà en attente pour le
processus.
.TP 
\fBRLIMIT_STACK\fP
La taille maximale de la pile du processus, en octets. Une fois cette limite
atteinte, un signal \fBSIGSEGV\fP est déclenché. Pour gérer ce signal, le
processus doit utiliser une pile spécifique pour signaux
(\fBsigaltstack\fP(2)).

Depuis Linux 2.6.23, cette limite détermine également la quantité d'espace
utilisé pour les paramètres et les variables d'environnement du processus\ ;
consultez \fBexecve\fP(2) pour plus de détails.
.SH "VALEUR RENVOYÉE"
En cas de réussite, zéro est renvoyé, sinon \-1 est renvoyé et \fIerrno\fP
contient le code d'erreur.
.SH ERREURS
.TP 
\fBEFAULT\fP
\fIrlim\fP pointe en dehors de l'espace d'adressage disponible.
.TP 
\fBEINVAL\fP
\fIresource\fP n'est pas valide\ ; ou, pour \fBsetrlimit\fP(),
\fIrlim\->rlim_cur\fP est plus grand que \fIrlim\->rlim_max\fP.
.TP 
\fBEPERM\fP
Un processus non privilégié a essayé d'utiliser \fBsetrlimit\fP() pour
augmenter ses limites souple ou stricte au delà de l'actuelle limite
stricte\ ; la capacité \fBCAP_SYS_RESOURCE\fP est nécessaire pour pouvoir faire
cela. Ou alors le processus essaye d'augmenter avec \fBsetrlimit\fP() la limite
souple ou stricte \fBRLIMIT_NOFILE\fP au\(hydessus des maxima du noyau
(\fBNR_OPEN\fP).
.SH CONFORMITÉ
SVr4, BSD\ 4.3, POSIX.1\-2001. \fBRLIMIT_MEMLOCK\fP et \fBRLIMIT_NPROC\fP
proviennent de BSD et ne sont pas définis dans POSIX.1\-2001\ ; ils sont
présents dans les BSD et Linux, mais dans peu d'autres
implémentations. \fBRLIMIT_RSS\fP vient de BSD et n'est pas défini dans
POSIX.1\-2001\ ; cependant, il est présent sur la plupart des
implémentations. \fBRLIMIT_MSGQUEUE\fP, \fBRLIMIT_NICE\fP, \fBRLIMIT_RTPRIO\fP,
\fBRLIMIT_RTTIME\fP et \fBRLIMIT_SIGPENDING\fP sont spécifiques à Linux.
.SH NOTES
Un processus fils créé avec \fBfork\fP(2) hérite des limites de ressource de
son père. Les limites de ressource sont préservées à travers un
\fBexecve\fP(2).

On peut fixer les limites de ressources de l'interpréteur de commandes en
utilisant la commande interne \fIulimit\fP (\fIlimit\fP dans \fBcsh\fP(1)). Les
limites de ressources de l'interpréteur de commandes sont héritées par les
processus qu'il crée pour exécuter les commandes.
.SH BOGUES
Dans les noyaux Linux plus anciens, les signaux \fBSIGXCPU\fP et \fBSIGKILL\fP
envoyés lorsqu'un processus dépassait les limites souple et stricte pour
\fBRLIMIT_CPU\fP étaient envoyés une seconde (CPU) plus tard qu'ils n'auraient
dû l'être. Cela a été corrigé dans le noyau 2.6.8.

.\" see http://marc.theaimsgroup.com/?l=linux-kernel&m=114008066530167&w=2
Dans les noyaux de la série 2.6 antérieurs à 2.6.17, une limite
\fBRLIMIT_CPU\fP à 0 est interprétée par erreur comme «\ pas de limite\ »
(comme \fBRLIM_INFINITY\fP). Depuis Linux\ 2.6.17, fixer la limite à 0 a un
effet, mais la limite est en fait d'une seconde.

En raison d'un bogue du noyau, \fBRLIMIT_RTPRIO\fP ne marche pas dans le noyau
2.6.12\ ; le problème a été corrigé dans le noyau 2.6.13.

.\" see http://marc.theaimsgroup.com/?l=linux-kernel&m=112256338703880&w=2
Dans le noyau 2.6.12, il y avait une différence de 1 entre les valeurs de
priorité renvoyées par \fBgetpriority\fP(2) et \fBRLIMIT_NICE\fP. Du coup, la
limite réelle pour la valeur de politesse était calculée comme \fI19\ \-\
rlim_cur\fP. Ceci est corrigé depuis le noyau 2.6.13.

Les noyaux antérieurs à 2.4.22 ne détectaient pas l'erreur \fBEINVAL\fP pour
\fBsetrlimit\fP() quand \fIrlim\->rlim_cur\fP était plus grand que
\fIrlim\->rlim_max\fP.
.SH "VOIR AUSSI"
\fBdup\fP(2), \fBfcntl\fP(2), \fBfork\fP(2), \fBgetrusage\fP(2), \fBmlock\fP(2),
\fBmmap\fP(2), \fBopen\fP(2), \fBquotactl\fP(2), \fBsbrk\fP(2), \fBshmctl\fP(2),
\fBsigqueue\fP(2), \fBmalloc\fP(3), \fBulimit\fP(3), \fBcore\fP(5), \fBcapabilities\fP(7),
\fBsignal\fP(7)
.SH COLOPHON
Cette page fait partie de la publication 3.23 du projet \fIman\-pages\fP
Linux. Une description du projet et des instructions pour signaler des
anomalies peuvent être trouvées à l'adresse
<URL:http://www.kernel.org/doc/man\-pages/>.
.SH TRADUCTION
Depuis 2010, cette traduction est maintenue à l'aide de l'outil
po4a <URL:http://po4a.alioth.debian.org/> par l'équipe de
traduction francophone au sein du projet perkamon
<URL:http://alioth.debian.org/projects/perkamon/>.
.PP
Christophe Blaess <URL:http://www.blaess.fr/christophe/> (1996-2003),
Alain Portal <URL:http://manpagesfr.free.fr/> (2003-2006).
Julien Cristau et l'équipe francophone de traduction de Debian\ (2006-2009).
.PP
Veuillez signaler toute erreur de traduction en écrivant à
<perkamon\-l10n\-fr@lists.alioth.debian.org>.
.PP
Vous pouvez toujours avoir accès à la version anglaise de ce document en
utilisant la commande
«\ \fBLC_ALL=C\ man\fR \fI<section>\fR\ \fI<page_de_man>\fR\ ».
