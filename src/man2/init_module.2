.\" Copyright (C) 2012 Michael Kerrisk <mtk.manpages@gmail.com>
.\" A few fragments remain from a version
.\" Copyright (C) 1996 Free Software Foundation, Inc.
.\"
.\" %%%LICENSE_START(VERBATIM)
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one.
.\"
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  The author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\"
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\" %%%LICENSE_END
.\"
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH INIT_MODULE 2 "7 janvier 2013" Linux "Manuel du programmeur Linux"
.SH NOM
init_module, finit_module \- Charger un module de noyau
.SH SYNOPSIS
.nf
\fBint init_module(void *\fP\fImodule_image\fP\fB, unsigned long \fP\fIlen\fP\fB,\fP
\fB                const char *\fP\fIparam_values\fP\fB);\fP

\fBint finit_module(int \fP\fIfd\fP\fB, const char *\fP\fIparam_values\fP\fB,\fP
\fB                 int \fP\fIflags\fP\fB);\fP
.fi

\fIRemarque\fP\ : il n'existe pas de fonctions glibc autour de ces appels
système\ ; consultez \fBNOTES\fP.
.SH DESCRIPTION
\fBinit_module\fP() charge une image ELF dans l'espace du noyau, réalise toutes
les réallocations de symboles nécessaires, initialise les paramètres du
module aux valeurs fournies par l'appelant et exécute ensuite la fonction
\fIinit\fP du module. Cet appel système nécessite des droits.

L'argument \fImodule_image\fP pointe vers un tampon contenant l'image binaire à
charger\ ; \fIlen\fP indique la taille du tampon. L'image du module devrait être
une image ELF valable, construite pour le noyau en fonctionnement.

L'argument \fIparam_values\fP est une chaîne contenant une liste de valeurs,
séparées par des espaces, de paramètres du module (définis dans le module en
utilisant \fBmodule_param\fP() et \fBmodule_param_array\fP()). Le noyau analyse
cette chaîne et initialise les paramètres indiqués. Toutes les
spécifications de paramètres sont de la forme\ :

\fInom\fP[\fB=\fP\fIvaleur\fP[\fB,\fP\fIvaleur\fP...]]

Le paramètre \fInom\fP est un de ceux définis dans le module en utilisant
\fImodule_param\fP() (consultez le fichier \fIinclude/linux/moduleparam.h\fP dans
les sources du noyau Linux). Le paramètre \fIvaleur\fP est facultatif pour les
paramètres de type \fIbool\fP et \fIinvbool\fP. Les valeurs des paramètres de
tableau sont indiqués en liste, séparés par des virgules.
.SS finit_module()
.\" commit 34e1169d996ab148490c01b65b4ee371cf8ffba2
.\" https://lwn.net/Articles/519010/
L'appel système \fBfinit_module\fP() est comme \fBinit_module\fP(), mais lit le
module à charger à partir du descripteur de fichier \fIfd\fP. Il est utile
quand l'authenticité d'un module du noyau peut être déterminée par son
emplacement sur le système de fichiers. Dans les cas où c'est possible, la
complication induite par la vérification cryptographique de modules signés
pour déterminer leur authenticité peut être évitée. L'argument
\fIparam_values\fP est comme pour \fBinit_module\fP().

.\" commit 2f3238aebedb243804f58d62d57244edec4149b2
L'argument \fIflags\fP modifie l'opération de \fBfinit_module\fP(). C'est un
masque OU bit à bit de zéro ou plusieurs des attributs suivants.
.TP 
\fBMODULE_INIT_IGNORE_MODVERSIONS\fP
Ignorer les hachages de version de symbole.
.TP 
\fBMODULE_INIT_IGNORE_VERMAGIC\fP
Ignorer la version magique du noyau.
.PP
.\" http://www.tldp.org/HOWTO/Module-HOWTO/basekerncompat.html
.\" is dated, but informative
Certaines vérifications de sécurité sont construites dans un module pour
s'assurer qu'il correspond au noyau sur lequel il est chargé. Ces
vérifications sont enregistrées quand le module est construit et utilisées
quand le module est chargé. D'abord, le module enregistre une chaîne
«\ vermagic\ » contenant le numéro de version du noyau et les fonctionnalités
principales (comme le type de microprocesseur). Ensuite, si le module a été
construit avec l'option de configuration \fBCONFIG_MODVERSIONS\fP activée, un
hachage de version est enregistré pour chaque symbole que le module
utilise. Ce hachage est basé sur les types de l'argument et la valeur de
retour pour la fonction nommée par le symbole. Dans ce cas, le numéro de
version du noyau dans la chaîne «\ vermagic\ » est ignoré, car les hachages de
version de symbole sont supposés être suffisamment fiables.

L'utilisation de l'attribut \fBMODULE_INIT_IGNORE_VERMAGIC\fP indique que la
chaîne «\ vermagic\ » est à ignorer, et l'attribut
\fBMODULE_INIT_IGNORE_MODVERSIONS\fP indique que les hachages de version de
symbole sont à ignorer. Si le noyau est construit pour permettre le
chargement forcé (c'est\-à\-dire configuré avec \fBCONFIG_MODULE_FORCE_LOAD\fP),
alors le chargement continuera, sinon il échouera avec \fBENOEXEC\fP comme
attendu pour les modules malformés.
.SH "VALEUR RENVOYÉE"
Ces appels système renvoient 0 en cas de succès, ou \-1 en cas d'échec,
auquel cas \fIerrno\fP contient le code d'erreur.
.SH ERREURS
.TP 
\fBEBADMSG\fP (depuis Linux 3.7)
La signature du module est mal formatée.
.TP 
\fBEBUSY\fP
Délai dépassé en essayant de résoudre une référence de symbole par ce
module.
.TP 
\fBEFAULT\fP
Un argument d'adresse faisait référence à un emplacement en dehors de
l'espace d'adressage accessible du processus.
.TP 
\fBENOKEY\fP (depuis Linux 3.7
.\" commit 48ba2462ace6072741fd8d0058207d630ce93bf1
.\" commit 1d0059f3a468825b5fc5405c636a2f6e02707ffa
.\" commit 106a4ee258d14818467829bf0e12aeae14c16cd7
La signature du module est incorrecte ou le noyau n'a pas de clef pour ce
module. Cette erreur n'est renvoyée que si le noyau a été configuré avec
\fBCONFIG_MODULE_SIG_FORCE\fP. Si le noyau n'a pas été configuré avec cette
option, alors un module incorrect ou non signé corrompt simplement le noyau.
.TP 
\fBENOMEM\fP
Mémoire épuisée.
.TP 
\fBEPERM\fP
L'appelant n'avait pas les droits (n'avait pas la capacité
\fBCAP_SYS_MODULE\fP), ou le chargement de module est désactivé (consultez
\fI/proc/sys/kernel/modules_disabled\fP dans \fBproc\fP(5)).
.PP
Les erreurs supplémentaires suivantes peuvent survenir pour
\fBinit_module\fP().
.TP 
\fBEEXIST\fP
Un module de ce nom est déjà chargé.
.TP 
\fBEINVAL\fP
.\" .TP
.\" .BR EINVAL " (Linux 2.4 and earlier)"
.\" Some
.\" .I image
.\" slot is filled in incorrectly,
.\" .I image\->name
.\" does not correspond to the original module name, some
.\" .I image\->deps
.\" entry does not correspond to a loaded module,
.\" or some other similar inconsistency.
\fIparam_values\fP est incorrect, ou certaines parties de l'image ELF de
\fImodule_image\fP contient des incohérences.
.TP 
\fBENOEXEC\fP
L'image binaire fournie dans \fImodule_image\fP n'est pas une image ELF, ou est
une image ELF incorrecte ou pour une autre architecture.
.PP
Les erreurs supplémentaires suivantes peuvent survenir pour
\fBfinit_module\fP().
.TP 
\fBEBADF\fP
Le fichier indiqué par \fIfd\fP n'est pas ouvert en lecture.
.TP 
\fBEFBIG\fP
Le fichier indiqué par \fIfd\fP est trop gros.
.TP 
\fBEINVAL\fP
\fIflags\fP n'est pas correct.
.TP 
\fBENOEXEC\fP
\fIfd\fP ne fait pas référence à un fichier ouvert.
.PP
En plus des erreurs précédentes, si la fonction \fIinit\fP du module est
exécutée et renvoie une erreur, alors \fBinit_module\fP() ou \fBfinit_module\fP()
échoue et \fIerrno\fP est définie à la valeur renvoyée par la fonction \fIinit\fP.
.SH VERSIONS
\fBfinit_module\fP() est disponible depuis Linux 3.8.
.SH CONFORMITÉ
\fBinit_module\fP() et \fBfinit_module\fP() sont spécifiques à Linux.
.SH NOTES
La glibc ne fournit pas de fonction autour de ces appels système\ ; utilisez
\fBsyscall\fP(2) pour les appeler.

Des renseignements concernant les modules chargés sont disponibles dans
\fI/proc/modules\fP et dans les arborescences de fichiers des sous\-répertoires
par module sous \fI/sys/module\fP.

Consultez le fichier \fIinclude/linux/module.h\fP dans les sources du noyau
Linux pour obtenir des renseignements de fond utiles.
.SS "Linux\ 2.4 et antérieurs"
.PP
Dans Linux\ 2.4 et antérieurs, l'appel système \fBinit_module\fP() était assez
différent\ :

\fB#include <linux/module.h>\fP

\fB int init_module(const char *\fP\fIname\fP\fB, struct module *\fP\fIimage\fP\fB);\fP

(les applications en espace utilisateur peuvent détecter la versions de
\fBinit_module\fP() disponible en appelant \fBquery_module\fP()\ ; ce dernier appel
échoue avec l'erreur \fBENOSYS\fP à partir de Linux\ 2.6)

L'ancienne version de l'appel système charge l'image de module réallouée
pointée par \fIimage\fP dans l'espace du noyau et exécute la fonction \fIinit\fP
du module. L'appelant doit fournir l'image réallouée (depuis Linux\ 2.6,
l'appel système \fBinit_module\fP() s'occupe de la réallocation).
.PP
L'image du module commence avec une structure module suivie par du code et
des données appropriés. Depuis Linux\ 2.2, la structure module est définie
comme suit\ :
.PP
.in +4n
.nf
struct module {
    unsigned long         size_of_struct;
    struct module        *next;
    const char           *name;
    unsigned long         size;
    long                  usecount;
    unsigned long         flags;
    unsigned int          nsyms;
    unsigned int          ndeps;
    struct module_symbol *syms;
    struct module_ref    *deps;
    struct module_ref    *refs;
    int                 (*init)(void);
    void                (*cleanup)(void);
    const struct exception_table_entry *ex_table_start;
    const struct exception_table_entry *ex_table_end;
#ifdef __alpha__
    unsigned long gp;
#endif
};
.fi
.in
.PP
On s'attend à ce que tous les champs pointeurs, à l'exception de \fInext\fP et
\fIrefs\fP, pointent vers l'intérieur du corps du module et qu'ils puissent
être initialisés de manière appropriée pour l'espace noyau, c'est\-à\-dire
relogés avec le reste du module.
.SH "VOIR AUSSI"
\fBcreate_module\fP(2), \fBdelete_module\fP(2), \fBquery_module\fP(2), \fBlsmod\fP(8),
\fBmodprobe\fP(8)
.SH COLOPHON
Cette page fait partie de la publication 3.52 du projet \fIman\-pages\fP
Linux. Une description du projet et des instructions pour signaler des
anomalies peuvent être trouvées à l'adresse
\%http://www.kernel.org/doc/man\-pages/.
.SH TRADUCTION
Depuis 2010, cette traduction est maintenue à l'aide de l'outil
po4a <http://po4a.alioth.debian.org/> par l'équipe de
traduction francophone au sein du projet perkamon
<http://perkamon.alioth.debian.org/>.
.PP
Alain Portal <http://manpagesfr.free.fr/>\ (2006-2008).
.PP
Veuillez signaler toute erreur de traduction en écrivant à
<perkamon\-fr@traduc.org>.
.PP
Vous pouvez toujours avoir accès à la version anglaise de ce document en
utilisant la commande
«\ \fBLC_ALL=C\ man\fR \fI<section>\fR\ \fI<page_de_man>\fR\ ».
